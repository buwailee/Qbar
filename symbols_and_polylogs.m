(* ::Package:: *)

(******************************************************************************
 *                                                                            *
 *    Symbols and polylogs   v0                                               *
 *                                                                            *
 *    S. Caron-Huot (October 2011)                                            *
 *                                                                            *
 ******************************************************************************)


(* This package requires the variables 'var','i','j','kk','l','m' to remain unassigned, although k and n can be assigned safely. *)


BeginPackage["BCFW`"]
Begin["Global`"]


(* ::Text:: *)
(*Going back and forth between numerical data and analytical data:*)
(*-factor[] is similar to Mathematica's 'FactorInteger', except it does not complain when meeting this it does not know how to factorize, like 3+Sqrt[5]; duplicates may arise.  Signs are dropped in the following cases: -mu2->mu2, I->1.*)
(*-makelistprime takes the object in 'list', evaluates them numerically using //.NEval, and attempts to find a distinct prime factor for each element*)
(*-Tocr[expr] converts a numerical expression to a product of object in 'list', using the prime factors computed by 'makelistprime'*)


SetAttributes[factor,Listable];
factor[i_]:=Flatten[Table[If[IntegerQ[fac[[1]]],{1,fac[[2]]}#&/@FactorInteger[fac[[1]]],{fac}],{fac,(FactorList[i]/.{{Power[j_,m_],l_}:>{j,m l}, j_Complex:>j/I}/.-mu2:>mu2)}],1]
makelistprime:=Block[{tmp=Reverse/@(factor[list//.NEval]//.{{m_/; m<3,_},i___}:>{i})},listprime={};
 Do[Do[If[Abs[tmp[[k,l,2]]]==1&&Position[Drop[tmp,{k}],tmp[[k,l,1]]]=={},AppendTo[listprime,tmp[[k,l,1]]];If[tmp[[k,l,2]]==-1,list[[k]]=1/list[[k]]];Break[]],
 {l,1,Length[tmp[[k]]]}],{k,1,Length[list]}];Length[listprime]==Length[list]]
SetAttributes[Tocr,Listable];
Tocr[i_]:=Block[{res=1,factors=factor[i//.NEval],tmp=0},Do[tmp=Position[factors,listprime[[k]],2]; res*=Product[list[[k]]^factors[[tmpp[[1]],2]],{tmpp,tmp}],{k,1,Length[list]}];
res (i/res//. NEval)];


(* ::Text:: *)
(*Operations on tensors:*)
(*  -Rules expand out completely each entry of the symbol, going as far as factoring integers into their prime factors*)
(*  -Rulesnofactor is similar, but does not factor integers*)
(*  -SBs remove nested tensors: SB[x,aSB[..]+bSB[...']] = a SB[x,...] + bSB[x,...']. Notice that nested tensors, when present, must absolutely be removed by //.SBs before 'Rules' is applied.*)
(*  -shuffle[] turns all products of SB[]'s into single SB's, using the shuffle algebra*)


SetAttributes[br,Orderless]
Rules={SB[___,1,___]:>0,SB[___,-1,___]:>0,SB[i___,j_ kk_,l___]->SB[i,j,l]+SB[i,kk,l],SB[i___,j_^kk_,l___]->kk SB[i,j,l],SB[i___,j_Rational|j_Integer|j_Complex/;Re[j]<0||PrimeQ[j]==False,kk___]:>Sum[s[[2]] SB[i,Abs[s[[1]]],kk],{s,factor[j]//.{ii___,{kkk_/;kkk==-1||kkk==I||kkk==-I,_},jj___}:>{ii,jj}}]};
Rulesnofactor={SB[___,1,___]:>0,SB[___,-1,___]:>0,SB[i___, j_ kk_,l___]->SB[i,j,l]+SB[i,kk,l],SB[i___, 1 /kk_,l___]->-SB[i,kk,l],SB[i___,(j_)^kk_,l___]->kk SB[i,j,l]};
SBs={SB[___,0,___]:>0,SB[i___,Null,j___]:>SB[i,j],SB[i___,(SB[j___]m_ :1)+l_:0,kk___]:>m SB[i,j,kk]+If[MatchQ[l,0],0,SB[i,l,kk]]};
shufflerules={SB[i__]SB[j__]:>SBtmp[i][j],SB[i__]^kk_:>SB[i]^(kk-2)SBtmp[i][i],SBtmp[i__][j__]:>Block[{p=Permutations@Flatten@{ConstantArray[0,Length[{i}]],ConstantArray[1,Length[{j}]]},ii,jj},
 Sum[ii=0;jj=0; SB@@Table[If[pp[[k]]==0,ii++;{i}[[ii]],jj++;{j}[[jj]]],{k,1,Length[pp]}],{pp,p}]]};
shuffleandexpand:=Expand[#//.shufflerules]&;
shuffle:=shuffleandexpand@shuffleandexpand@shuffleandexpand[#]&


(* ::Text:: *)
(*Polylogs, and conversion to symbol.  The polylogs are Li[1][x]=-log(1-x), Li[n][x]=PolyLog[n,x], Li[i,j][x,y]=....*)
(*With empty argument, 'diffpolylogs[]' is a substitution rule which turns first derivatives of Li's (as generated by Mathematica's D), into their correct expression.*)
(*This is used by 'tosymbol' as a means to compute the symbol of a general product of Li[]'s and Lg[]'s.*)
(*(Note I have to use 'Lg' as opposed to 'Log', because Mathematica's Log behaves badly on negative integers)*)


defaultdlog:=(#1 (D[Log[#2],var]/.var->#3))&
diffpolylogs[dlog_:defaultdlog]:={Derivative[1][Lg][j_]:>dlog[1,var,j],Derivative[1][Li[1]][j_]:>-dlog[1,1-var,j],Derivative[kk__][Li[i__]][j__]:>(Block[{k=Position[{kk},1][[1,1]],len=Length[{i}]},If[{i}[[k]]>1,dlog[(Li@@({i}-UnitVector[len,k]))@@{j},var,{j}[[k]]],If[k<len,dlog[(Li@@Drop[{i},{k}])@@Drop[{j}*(1+UnitVector[len,k+1]*({j}[[k]]-1)),{k}],var/(1-var),{j}[[k]]],0]+If[k>1, dlog[(Li@@Drop[{i},{k}])@@Drop[{j}*(1+UnitVector[len,k-1]*({j}[[k]]-1)),{k}],1-var,{j}[[k]]],0]-If[k==len,dlog[(Li@@Drop[{i},{k}])@@Drop[{j},{k}],1-var,{j}[[k]]],0]]]/.Li[1][k_]:>-Lg[1-k])}
(* act with a derivative on all entries, to get the last entry of the symbol. //. this will produce the symbol. *)
tosymbol:=shuffle[(#//.{Lg[i_]:>SB[i],Log[i_]:>SB[i],Li[i_][1]:>0,Li[i__][j__]:>Together[((((D[Li[i]@@(aa{j}),aa])/.aa->1)/.diffpolylogs[If[MatchQ[#1,1],SB[#2/.var->#3]/#3,SB[#1,#2/.var->#3]/#3]&]))]})//.SBs]&


(* ::Text:: *)
(*Side - routines for expanding out the arguments of logarithms, and for keeping the leading term in a parameter ' eps' *)
(* (expandeps[] : assumes expression is at most linear in epsilon; *)
(*   expandepsrobust[] : general case (with no inverse power of epsilon))*)


blowlgs={Lg[1]:>0,Lg[i_]:>Sum[fact[[2]]Lg[fact[[1]]],{fact,factor[i]/.{{j___,{-1,1},kk___}:>{j,kk},{j___,{1,1},kk___}:>{j,kk}}}]};
expandeps:=Block[{ser=Normal[Series[#,{eps,0,1}]]},If[!MatchQ[ser/.eps->0,0],ser/.eps->0,ser]]&
expandepsrobust:=Block[{ser=0},For[order=0,order<10&&MatchQ[ser,0],order++,ser=Normal@Series[#,{eps,0,order}]];ser]&


(* ::Text:: *)
(*'integrate[]': Routine to compute the symbol of the integral \int_0^\infty d\[Tau]/(\[Tau]-a) F, given the symbol of F.*)
(*The input is a bunch of products of the form Int[a] F, where Int[a] means the rational part of the integrand has a pole at a, and F is transcendental function, supplied either in 'Lg[]/Li[][]' form or in SB[] form.*)
(*The first step is to convert the integrand to an internal notation, which is a symbol with entries involving constants and 'linear[b]' objects, where linear[b] \equiv (\[Tau]-b).*)
(**)
(*This code works on the assumption that the integral converges at 0 and infinity; since no real test of this assumption is made this has to be checked independently.*)


tolinear:=Product[If[MatchQ[D[fact[[1]],\[Tau]],0],fact[[1]],Product[linear[\[Tau]/.sol],{sol,Solve[fact[[1]]==0,\[Tau]]}]Last@CoefficientList[fact[[1]],\[Tau]]]^fact[[2]],{fact,FactorList[#]}]&
RulesIntRight={Int[i_][j___,kk_ l_]:>Int[i][j,kk]+Int[i][j,l],Int[i_][j___,1/kk_]:>-Int[i][j,kk],Int[i_][j___,kk_^l_]:>l Int[i][j,kk]};
evalat0:=#/.{linear[i_]:>If[i==0,eps,i]}&
dooneint={Int[i_][sym___]:>If[Length[{sym}]==0,-SB[evalat0[linear[i]]],-SB[SB@@(evalat0/@{sym}),evalat0[linear[i]]]+
 Block[{next=((Int[i]@@Drop[{sym},-1])//.RulesIntRight)},If[!MatchQ[Last[{sym}],linear[_]],SB[next,Last[{sym}]],If[i=={sym}[[-1,1]],0,SB[next-(next/.Int[i]:>Int[{sym}[[-1,1]]]),i-{sym}[[-1,1]]]]]]]};
(* argument to 'setupint' and 'integrate' should be of the form: sum of Int[endpoints] x transcendental functions of \[Tau]-only *)
setupint:=(Expand[tosymbol[#/.Int[Infinity]:>0]]/.{Int[i_]SB[j__]:>((Int[i]@@(tolinear/@{j}))//.RulesIntRight),Int[i_]:>Int[i][]})&
integrate:=(setupint[#]//.dooneint//.SBs)&


End[]
EndPackage[]
